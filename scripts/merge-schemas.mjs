#!/usr/bin/env node
/**
 * Schema Merging Script for Convex Modular Architecture
 *
 * This script merges schema definitions from different modules
 * into a single schema.ts file for Convex compilation.
 */

import { existsSync, readFileSync, writeFileSync } from "fs";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const PROJECT_ROOT = resolve(__dirname, "..");
const BACKEND_PATH = resolve(PROJECT_ROOT, "packages/backend");
const SCHEMA_OUTPUT = resolve(BACKEND_PATH, "convex/schema.ts");
const SCHEMA_BACKUP = resolve(BACKEND_PATH, "convex/schema.backup.ts");

// Module schema configurations
const MODULE_SCHEMAS = [
	{
		name: "core",
		path: resolve(PROJECT_ROOT, "packages/core/src/validators"),
		exports: [
			"usersValidator",
			"workspacesValidator",
			"workspaceMembersValidator",
		],
	},
	// Future modules will be added here
	// {
	//   name: 'ideas-logic',
	//   path: resolve(PROJECT_ROOT, 'packages/ideas-logic/src/validators'),
	//   exports: ['ideasValidator', 'foldersValidator', 'tagsValidator'],
	// },
];

/**
 * Generate the merged schema content
 */
function generateMergedSchema() {
	const imports = [];
	const validators = [];

	// Add base imports
	imports.push(`import { authTables } from "@convex-dev/auth/server";`);
	imports.push(`import { defineSchema, defineTable } from "convex/server";`);
	imports.push(`import { v } from "convex/values";`);
	imports.push("");

	// Add comment header
	const header = `/**
 * Pulse Workspace Schema - Generated File
 *
 * This schema is automatically generated by scripts/merge-schemas.mjs
 * DO NOT EDIT THIS FILE DIRECTLY - it will be overwritten.
 *
 * To modify the schema:
 * 1. Edit the validators in packages/*/src/validators/
 * 2. Run 'npm run build:schema' to regenerate this file
 */`;

	imports.push(header);
	imports.push("");

	// Read existing schema for complex table definitions that aren't modularized yet
	let existingSchemaContent = "";
	try {
		existingSchemaContent = readFileSync(SCHEMA_OUTPUT, "utf-8");
	} catch (error) {
		console.warn("Could not read existing schema, creating from scratch");
	}

	// Extract existing validators and tables
	const existingValidators = extractExistingValidators(existingSchemaContent);
	const existingTables = extractExistingTables(existingSchemaContent);

	// Add module imports (for future use when modules are ready)
	// Currently commented out until @pulse/core validators are properly exported
	// for (const module of MODULE_SCHEMAS) {
	//   if (existsSync(module.path)) {
	//     imports.push(`// Validators from ${module.name} module`);
	//     for (const exportName of module.exports) {
	//       imports.push(`import { ${exportName} } from "@pulse/core/validators";`);
	//     }
	//     imports.push('');
	//   }
	// }

	// Build schema definition
	const schemaContent = `
export default defineSchema({
  // Auth tables with custom users table
  ...authTables,

  // Users: Extended with tokenIdentifier for unified testing
  users: defineTable(usersValidator)
    .index("by_token", ["tokenIdentifier"]) // For auth shim lookups
    .index("email", ["email"]), // Preserve existing email index

  // Workspaces: The primary isolation boundary
  workspaces: defineTable(workspacesValidator)
    .index("by_slug", ["slug"]) // Unique constraint enforced in code
    .index("personal_by_owner", ["ownerUserId", "isPersonal"]),

  // Workspace Members: Role-based access control
  workspaceMembers: defineTable(workspaceMembersValidator)
    .index("by_workspace_user", ["workspaceId", "userId"]) // Primary lookup
    .index("by_user", ["userId"]) // User's workspaces
    .index("by_workspace", ["workspaceId"]), // Workspace members

${existingTables}
});`;

	// Add existing validators that aren't modularized yet
	const validatorDefinitions = existingValidators;

	return [...imports, validatorDefinitions, "", schemaContent].join("\n");
}

/**
 * Extract validator definitions from existing schema
 */
function extractExistingValidators(content) {
	if (!content) return "";

	// Extract all export const *Validator = { ... } definitions
	const validatorRegex = /export const (\w+Validator)\s*=\s*{[\s\S]*?^};/gm;
	const matches = content.match(validatorRegex);

	if (!matches) return "";

	return matches
		.filter((match) => {
			// Don't include validators that are now in modules
			const modulizedValidators = [
				"usersValidator",
				"workspacesValidator",
				"workspaceMembersValidator",
			];
			return !modulizedValidators.some((name) => match.includes(name));
		})
		.join("\n\n");
}

/**
 * Extract table definitions from existing schema
 */
function extractExistingTables(content) {
	if (!content) return "  // No existing tables found";

	// Extract everything between defineSchema({ and }); but exclude auth tables and core tables
	const schemaMatch = content.match(/defineSchema\s*\(\s*{([\s\S]*?)}\s*\);?/);
	if (!schemaMatch) return "  // No schema definition found";

	const schemaBody = schemaMatch[1];

	// Remove auth tables spread and core tables
	const tables = schemaBody
		.replace(/\s*\.\.\.authTables,?/g, "")
		.replace(/\s*\/\/\s*Auth tables[\s\S]*?\n/, "")
		.replace(/\s*users:\s*defineTable[\s\S]*?\),\s*/g, "")
		.replace(/\s*workspaces:\s*defineTable[\s\S]*?\),\s*/g, "")
		.replace(/\s*workspaceMembers:\s*defineTable[\s\S]*?\),\s*/g, "")
		.trim();

	if (!tables) return "  // No additional tables found";

	return tables
		.split("\n")
		.map((line) => "  " + line)
		.join("\n");
}

/**
 * Backup existing schema
 */
function backupExistingSchema() {
	if (existsSync(SCHEMA_OUTPUT)) {
		try {
			const existingContent = readFileSync(SCHEMA_OUTPUT, "utf-8");
			writeFileSync(SCHEMA_BACKUP, existingContent);
			console.log("‚úÖ Backed up existing schema to schema.backup.ts");
		} catch (error) {
			console.warn("‚ö†Ô∏è Could not backup existing schema:", error.message);
		}
	}
}

/**
 * Main execution
 */
function main() {
	console.log("üîÑ Merging schemas...");

	try {
		// Backup existing schema
		backupExistingSchema();

		// Generate merged schema
		const mergedSchema = generateMergedSchema();

		// Write new schema
		writeFileSync(SCHEMA_OUTPUT, mergedSchema, "utf-8");

		console.log("‚úÖ Successfully merged schemas");
		console.log("üìÅ Output:", SCHEMA_OUTPUT);

		// Show what was included
		console.log("\nüì¶ Included modules:");
		for (const module of MODULE_SCHEMAS) {
			if (existsSync(module.path)) {
				console.log(`  - ${module.name}: ${module.exports.join(", ")}`);
			} else {
				console.log(`  - ${module.name}: (not found)`);
			}
		}
	} catch (error) {
		console.error("‚ùå Error merging schemas:", error.message);

		// Restore backup if available
		if (existsSync(SCHEMA_BACKUP)) {
			try {
				const backupContent = readFileSync(SCHEMA_BACKUP, "utf-8");
				writeFileSync(SCHEMA_OUTPUT, backupContent);
				console.log("üîÑ Restored schema from backup");
			} catch (restoreError) {
				console.error("‚ùå Could not restore backup:", restoreError.message);
			}
		}

		process.exit(1);
	}
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	main();
}
